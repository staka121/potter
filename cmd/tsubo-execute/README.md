# tsubo-execute

Tsubo Execution Engine - Generates implementation prompts and optionally executes them with Claude API.

## Overview

`tsubo-execute` supports two modes:

**Phase 1 (Default): Prompt Generation**
1. Loads an implementation plan (generated by `tsubo-plan`)
2. Generates comprehensive prompts for AI agents
3. Outputs prompts to files for manual execution

**Phase 2 (--execute flag): Automated Execution**
1. Generates prompts (same as Phase 1)
2. Calls Claude API to execute implementations
3. Manages wave-based parallel execution
4. Saves responses and tracks progress

## Installation

### Build from source

```bash
# From the project root
go build -o tsubo-execute ./cmd/tsubo-execute

# Or install to $GOPATH/bin
go install ./cmd/tsubo-execute
```

## Usage

### Phase 1: Generate prompts only (default)

```bash
tsubo-execute <plan.json>
```

### Phase 2: Execute with Claude API

```bash
export ANTHROPIC_API_KEY=your-api-key
tsubo-execute --execute <plan.json>
```

### Complete Workflow

```bash
# Step 1: Generate implementation plan
./tsubo-plan ./poc/contracts/tsubo-todo-app.tsubo.yaml

# Step 2a: Generate prompts only (Phase 1)
./tsubo-execute /tmp/tsubo-implementation-plan.json

# Step 2b: OR execute with Claude API (Phase 2)
export ANTHROPIC_API_KEY=your-api-key
./tsubo-execute --execute /tmp/tsubo-implementation-plan.json
```

## What it does

### Step 1: Load implementation plan
Reads the JSON plan file generated by `tsubo-plan`.

### Step 2: Generate implementation prompts
For each object in the plan, generates a comprehensive prompt that includes:

1. **Context files** (embedded in prompt):
   - `PHILOSOPHY.md` - Tsubo's core philosophy
   - `DEVELOPMENT_PRINCIPLES.md` - Docker First, questioning timing
   - `WHY_GO.md` - Why Go language minimizes hallucination
   - `CONTRACT_DESIGN.md` - How to read contracts

2. **Contract** (embedded in prompt):
   - The complete `.object.yaml` contract for the service

3. **Implementation instructions**:
   - Output directory
   - Required files (main.go, Dockerfile, etc.)
   - Principles to follow
   - Dependencies to handle

### Output

Prompts are saved to `/tmp/tsubo-prompt-<service-name>.md`

Example output:
```
/tmp/tsubo-prompt-user-service.md    (55KB, ~1,735 lines)
/tmp/tsubo-prompt-todo-service.md    (65KB, ~2,017 lines)
```

Each prompt is self-contained and includes everything an AI agent needs to implement the service.

## Prompt Structure

```markdown
# Implementation Task: <service-name>

## Step 1: Read and understand context files
- PHILOSOPHY.md (full content)
- DEVELOPMENT_PRINCIPLES.md (full content)
- WHY_GO.md (full content)
- CONTRACT_DESIGN.md (full content)

## Step 2: Read the contract
- <service-name>.object.yaml (full content)

## Step 3: Understand dependencies
- List of dependent services
- Communication guidelines

## Step 4: Implement the service
- Implementation directory
- Required files
- Important principles
- Output location
```

## Next Steps

After generating prompts:

1. **Review prompts**:
   ```bash
   cat /tmp/tsubo-prompt-user-service.md
   ```

2. **Execute with AI agents**:
   - **Manual**: Copy prompt content and paste into Claude Code or other AI tool
   - **Automated** (Phase 2): Use Claude API to execute automatically

3. **Follow wave order**:
   - Wave 0: Implement all objects in parallel
   - Wave 1: Wait for Wave 0 completion, then implement
   - Continue for additional waves

## Example Workflow

```bash
# 1. Generate implementation plan
./tsubo-plan ./poc/contracts/tsubo-todo-app.tsubo.yaml

# 2. Generate prompts
./tsubo-execute /tmp/tsubo-implementation-plan.json

# 3. Review prompts
ls -lh /tmp/tsubo-prompt-*.md

# 4. Implement Wave 0 (parallel)
# - Use AI agent with /tmp/tsubo-prompt-user-service.md

# 5. Implement Wave 1 (after Wave 0 completes)
# - Use AI agent with /tmp/tsubo-prompt-todo-service.md

# 6. Test implementations
cd poc/implementations/user-service
./test-contract.sh

cd ../todo-service
./test.sh
```

## Phase 2 Features (--execute)

✅ **Implemented:**
- **Direct Claude API integration**: Calls Claude API automatically
- **Parallel execution**: Launches multiple implementations per wave
- **Wave-based ordering**: Respects dependency order
- **Progress tracking**: Shows real-time implementation status
- **Error handling**: Captures and reports failures
- **Response saving**: Saves API responses to /tmp/tsubo-response-*.md

### Requirements for Phase 2

1. **API Key**: Set `ANTHROPIC_API_KEY` environment variable
   ```bash
   export ANTHROPIC_API_KEY=sk-ant-...
   ```

2. **API Credits**: Ensure sufficient credits in your Anthropic account

3. **Model**: Uses `claude-sonnet-4-5-20250929` by default

### Phase 2 Execution Flow

1. Load implementation plan
2. For each wave (in order):
   - Generate prompts for all objects in wave
   - Execute implementations in parallel (within wave)
   - Wait for all objects in wave to complete
   - Check for failures (stop if any fail)
   - Proceed to next wave
3. Print summary with timing and success/failure status

## Architecture

```
tsubo-execute
├── Load Plan (JSON)
├── For each Wave:
│   ├── For each Object:
│   │   ├── Read context files
│   │   ├── Read contract
│   │   ├── Generate prompt
│   │   └── Save to file
│   └── Wait for wave completion (manual in Phase 1)
└── Output prompts
```

## Philosophy

This tool embodies the Tsubo principle:
- **Human defines "what"**: Contracts specify requirements
- **AI implements "how"**: Generated prompts guide AI agents
- **Automation where it matters**: Prompt generation is automated
- **Human in the loop**: Execution is manual (for now)

Phase 1 focuses on getting the prompts right. Phase 2 will automate execution.

## License

MIT
