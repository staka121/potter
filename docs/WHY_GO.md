# Why Go Language?

## TL;DR

**Tsubo chose Go as its target language.**
The reason is simple: **Go's characteristic of "same code regardless of who writes it" dramatically reduces AI hallucinations.**

## Go Language Design Philosophy and AI-Driven Development Compatibility

### 1. One Obvious Way

**Go's Design Philosophy:**
> "There should be one-- and preferably only one --obvious way to do it."

**Meaning for AI-Driven Development:**
- AI doesn't get confused about "how to write it"
- Fewer choices = fewer hallucinations
- Higher consistency in generated code

**Example: Error Handling**

In Go, there's essentially one pattern for error handling:
```go
result, err := doSomething()
if err != nil {
    return nil, fmt.Errorf("failed to do something: %w", err)
}
```

In other languages (e.g., TypeScript), there are multiple ways:
```typescript
// Option 1: try-catch
try {
    const result = await doSomething();
} catch (error) {
    // ...
}

// Option 2: Promise .catch()
doSomething().catch(error => {
    // ...
});

// Option 3: async/await with try-catch
// Option 4: Result type pattern
// etc.
```

When AI has too many options, it gets confused and tends to generate inconsistent code.

### 2. Simple Language Specification

**Go Language Specification:**
- Only **25 keywords** (C++: 95, Rust: 50+)
- No exceptions (returns error values)
- Recently added generics, but simple
- No classes (structs and interfaces)
- No inheritance (composition)

**Meaning for AI-Driven Development:**
- Fewer concepts for AI to understand
- Less confusion from complex language features
- Simpler prompt context

### 3. Standard Formatting (gofmt)

**Go's Characteristic:**
- `gofmt` provided as standard
- Indentation, line breaks, spaces automatically unified
- **Zero debates about code style**

**Meaning for AI-Driven Development:**
- AI-generated code automatically unified
- No hallucinations about formatting
- Reviews can focus on code content

### 4. Explicit Error Handling

**Go's Design:**
```go
func createUser(email string) (*User, error) {
    if !isValidEmail(email) {
        return nil, errors.New("invalid email")
    }

    user, err := db.Insert(email)
    if err != nil {
        return nil, fmt.Errorf("failed to insert: %w", err)
    }

    return user, nil
}
```

Errors are treated as **values** and explicitly checked.

**Meaning for AI-Driven Development:**
- Error cases less likely to be overlooked
- AI can clearly understand "where errors should be returned"
- No implicit control flow from exceptions

### 5. Rich Standard Library

**Go's Standard Library:**
- `net/http`: HTTP server/client
- `encoding/json`: JSON encoding/decoding
- `database/sql`: Database connections
- `testing`: Testing framework
- `context`: Context management

**Meaning for AI-Driven Development:**
- Fewer external dependencies = less AI confusion
- Established standard patterns
- Abundant documentation

## Comparison with Other Languages

### Rust's Challenges

**Good Points:**
- ✅ Very high type safety
- ✅ Excellent performance
- ✅ Memory safety

**Challenges from AI-Driven Development Perspective:**
- ❌ Complex concepts like lifetime, ownership, borrowing
- ❌ Multiple ways to achieve the same thing (`String` vs `&str`, `Vec` vs `&[T]`, etc.)
- ❌ AI prone to hallucinations
- ❌ Many compile errors, difficult to fix

**Example: String Handling**
```rust
// AI gets confused about which to use
fn process1(s: String) { }        // Takes ownership
fn process2(s: &str) { }          // Borrows (string slice)
fn process3(s: &String) { }       // Borrows (reference to String)
```

In Go:
```go
func process(s string) { }  // Just this
```

### TypeScript's Challenges

**Good Points:**
- ✅ Rich Web/Node.js ecosystem
- ✅ Flexible type system

**Challenges from AI-Driven Development Perspective:**
- ❌ JavaScript's flexibility becomes a hindrance (diverse ways to write)
- ❌ Complex configuration (tsconfig.json, webpack, vite, etc.)
- ❌ Type safety loopholes with `any` type
- ❌ Complex error handling with Promise/async/await

### Python's Challenges

**Good Points:**
- ✅ Simple and readable
- ✅ Rich AI/ML ecosystem

**Challenges from AI-Driven Development Perspective:**
- ❌ Dynamic typing (type hints are not complete)
- ❌ Low performance (sometimes unsuitable for microservices)
- ❌ Many runtime errors

## Effects of Go's "Simplicity"

### Effect 1: Reduced Hallucinations

**Measurable Metrics:**
- Compile error occurrence rate
- Runtime error occurrence rate
- Number of review comments

**Effects from Go's Simplicity:**
- Fewer choices → AI more likely to choose correct pattern
- Explicit error handling → Fewer error case oversights
- Type system → Fewer type-related errors

### Effect 2: Consistent Codebase

**Go Code Written by Humans:**
```go
func GetUser(id string) (*User, error) {
    user, err := db.Query("SELECT * FROM users WHERE id = ?", id)
    if err != nil {
        return nil, err
    }
    return user, nil
}
```

**Go Code Generated by AI:**
```go
func GetUser(id string) (*User, error) {
    user, err := db.Query("SELECT * FROM users WHERE id = ?", id)
    if err != nil {
        return nil, err
    }
    return user, nil
}
```

**→ Nearly identical code!**

### Effect 3: Efficient Reviews

- No code style debates (unified by gofmt)
- Fast reviews due to consistent patterns
- AI-generated code indistinguishable from human-written code

## Go Language's Role in Tsubo

### 1. Orchestrator
- **Language: Go**
- Reason: Concurrency (goroutines), simplicity

### 2. Validator (Verification Engine)
- **Language: Go** (initially considered Rust, but unified to Go)
- Reason: Codebase unification, sufficient type safety

### 3. Generated Services
- **Recommended Language: Go**
- Reason: Minimize AI hallucinations
- Future support planned for TypeScript, Python

### 4. CLI Tool
- **Language: Go**
- Reason: Single binary distribution, cross-platform

## Go's Limitations and Countermeasures

### Limitation 1: Weaker Generics (improved since Go 1.18)
**Countermeasure:**
- Use generics only where needed
- Supplement with code generation

### Limitation 2: Performance Inferior to Rust
**Countermeasure:**
- Go is sufficient for most microservices
- Individually optimize where performance is truly needed

### Limitation 3: Dependency Injection Not Supported at Language Level
**Countermeasure:**
- Adopt simple struct-based DI
- Don't use complex DI frameworks (confuses AI)

## Conclusion

**Why Tsubo Chooses Go:**

1. ✅ **Same code regardless of who writes it** → Minimize AI hallucinations
2. ✅ **Simple language specification** → Easy for AI to understand
3. ✅ **Explicit error handling** → Prevent error case oversights
4. ✅ **Standard formatting (gofmt)** → Unified code style
5. ✅ **Microservices ecosystem** → Practical
6. ✅ **Unified codebase** → Both Orchestrator and Validator in Go

**Tsubo's Philosophy:**
> "To minimize AI hallucinations, choose the simplest and most consistent language.
> That is Go."

---

## References

- [Go Proverbs](https://go-proverbs.github.io/)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
