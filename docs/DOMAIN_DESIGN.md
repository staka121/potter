# ドメイン設計ガイド

## Tsubo におけるドメインの役割

### 核心原則

**1つの壺 = 1つの固体オブジェクト（ドメイン）= 1つのマイクロサービス**

**ドメインは、壺の中に入れる固体オブジェクトである。**

```
┌─────────────────────────────────────────┐
│           システム全体                   │
│                                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │  壺 1   │  │  壺 2   │  │  壺 3   │ │
│  │  [User] │  │ [TODO]  │  │ [Auth]  │ │ ← 固体オブジェクト
│  │  固体   │  │  固体   │  │  固体   │ │
│  └─────────┘  └─────────┘  └─────────┘ │
│       ↓             ↓             ↓     │
│  user-service  todo-service  auth-service│
└─────────────────────────────────────────┘

壺 = 容器（境界）
固体オブジェクト = ドメイン（具体的なビジネス概念）
```

## ドメインとは何か

### ドメインの定義

**ドメイン（Domain）** とは：

**壺の中に入れる固体オブジェクトである。**

より具体的には：
- ビジネス上の概念の境界
- 固有のユビキタス言語を持つ領域
- 独立して変更・進化できる単位
- **触れることができる、具体的な概念**

### 物理的なイメージ

```
壺（容器）
  │
  ├─ 形: マイクロサービスの境界
  │
  └─ 中身: 固体オブジェクト（ドメイン）
         │
         ├─ 表面: インターフェース（Contract）
         │
         └─ 内部: 実装（AIが決める）

例:
- TODO という固体オブジェクトを todo-service という壺に入れる
- User という固体オブジェクトを user-service という壺に入れる
```

### Tsubo におけるドメインの特徴

1. **固体性**: 具体的で触れることができる概念
2. **独立性**: 他のドメイン（オブジェクト）に依存せず動作する
3. **凝集性**: 関連する概念が1つにまとまっている
4. **明確な境界**: 何が含まれ、何が含まれないかが明確
5. **ユビキタス言語**: そのドメイン固有の用語がある

## ドメイン境界の見極め方

### 良いドメイン分割の指標

#### ✅ 明確なビジネス概念がある

```yaml
# 良い例: TODO ドメイン
domain: task-management
concepts:
  - TODO アイテム
  - ステータス（pending/completed）
  - タスクの優先度
  - 期限

# 悪い例: data-service
domain: generic-data
concepts:
  - データ（何のデータ？）
  - エンティティ（何のエンティティ？）
```

#### ✅ ユビキタス言語がある

```
TODO ドメインの言語:
- タスク、TODO アイテム
- 完了する、未完了
- 期限、優先度

User ドメインの言語:
- ユーザー、アカウント
- サインアップ、ログイン
- プロフィール、設定
```

#### ✅ 独立して変更できる

```
TODO ドメインの変更例:
- ステータスに "in-progress" を追加
- 優先度フィールドを追加
- サブタスク機能を追加

→ User ドメインに影響を与えない
→ 独立してデプロイ可能
```

### 悪いドメイン分割のアンチパターン

#### ❌ 技術層による分割

```
# 悪い例
- api-service
- database-service
- cache-service

→ ビジネス概念ではなく技術層で分割
→ 変更時に複数サービスの修正が必要
```

#### ❌ CRUD による分割

```
# 悪い例
- create-service
- read-service
- update-service
- delete-service

→ 操作で分割、ドメインの境界が不明確
→ ビジネスロジックが分散
```

#### ❌ 過度な細分化

```
# 悪い例
- user-create-service
- user-read-service
- user-update-service
- user-delete-service

→ 1つの User ドメインを不必要に分割
→ ネットワークオーバーヘッドが増大
```

## ドメイン設計のプロセス

### Step 1: ビジネス概念の抽出

```
例: TODO アプリケーション

ビジネス概念:
1. タスク管理 → TODO ドメイン
2. ユーザー管理 → User ドメイン
3. 認証・認可 → Auth ドメイン
4. 通知 → Notification ドメイン
```

### Step 2: ドメイン境界の定義

```yaml
# TODO ドメイン
domain_boundary:
  included:
    - TODO の CRUD 操作
    - ステータス管理
    - フィルタリング、検索

  excluded:
    - ユーザー情報の管理（User ドメイン）
    - 認証トークンの発行（Auth ドメイン）
    - メール通知（Notification ドメイン）
```

### Step 3: ドメイン間の依存関係の明確化

```yaml
# TODO ドメインの依存関係
dependencies:
  services:
    - name: auth-service
      reason: TODO の作成者を識別するため
      type: authentication

    - name: notification-service
      reason: TODO 完了時に通知を送る
      type: optional  # 通知失敗しても TODO 操作は成功
```

### Step 4: Contract の定義

```yaml
service:
  name: todo-service
  domain: task-management

  context:
    domain_boundary: |
      【含む】
      - TODO の CRUD
      - ステータス管理

      【含まない】
      - ユーザー管理
      - 認証・認可
```

## ドメインとマイクロサービスの対応

### 基本原則

```
1つのドメイン → 1つの Contract → 1つのマイクロサービス
```

### 具体例

#### TODO アプリケーションの全体像

```
┌─────────────────────────────────────────────┐
│          TODO アプリケーション               │
└─────────────────────────────────────────────┘
              │
    ┌─────────┼─────────┬─────────┐
    │         │         │         │
    ▼         ▼         ▼         ▼
┌────────┐┌────────┐┌────────┐┌────────┐
│  User  ││  TODO  ││  Auth  ││ Notify │
│ Domain ││ Domain ││ Domain ││ Domain │
└────────┘└────────┘└────────┘└────────┘
    │         │         │         │
    ▼         ▼         ▼         ▼
┌────────┐┌────────┐┌────────┐┌────────┐
│  user  ││  todo  ││  auth  ││ notify │
│-service││-service││-service││-service│
└────────┘└────────┘└────────┘└────────┘
```

#### 各ドメインの責務

```yaml
# User ドメイン
responsibilities:
  - ユーザーの CRUD
  - プロフィール管理
  - アカウント設定

# TODO ドメイン
responsibilities:
  - TODO の CRUD
  - ステータス管理
  - タスクのフィルタリング

# Auth ドメイン
responsibilities:
  - 認証トークンの発行
  - トークンの検証
  - セッション管理

# Notification ドメイン
responsibilities:
  - メール送信
  - プッシュ通知
  - 通知設定の管理
```

## ドメイン独立性のメリット

### 1. 並列開発が可能

```
複数のドメインを同時に開発:
- チーム A: User ドメイン
- チーム B: TODO ドメイン
- チーム C: Auth ドメイン

→ 互いに影響を与えずに開発できる
```

### 2. 独立したデプロイ

```
TODO ドメインの変更:
- todo-service のみデプロイ
- 他のサービスは影響を受けない
- ダウンタイムなし
```

### 3. スケーラビリティ

```
TODO サービスの負荷が高い場合:
- todo-service のみスケールアウト
- 他のサービスは現状維持
- コスト効率が良い
```

### 4. 技術スタックの柔軟性

```
各ドメインで最適な技術を選択:
- user-service: Go（シンプル、高速）
- todo-service: Go（AI 駆動開発に最適）
- notification-service: Python（メールライブラリが豊富）
```

## チェックリスト

### ドメイン設計時

- [ ] 明確なビジネス概念があるか
- [ ] ユビキタス言語が定義されているか
- [ ] 他のドメインと独立して変更できるか
- [ ] ドメイン境界が明確か（含む/含まないが定義されているか）
- [ ] 過度に細分化されていないか
- [ ] 技術層ではなくビジネス概念で分割されているか

### Contract 定義時

- [ ] `domain` フィールドが設定されているか
- [ ] `domain_boundary` が明確に定義されているか
- [ ] 他のドメインへの依存関係が明示されているか
- [ ] そのドメイン固有の責務が記述されているか

## まとめ

**Tsubo における ドメイン = 壺 の関係:**

```
壺 = 容器（境界、マイクロサービス）
  ↓
固体オブジェクト = ドメイン（具体的なビジネス概念）
  ↓
内部構造 = 実装（AIが決める）

1つの壺 = 1つの固体オブジェクト（ドメイン）= 1つのマイクロサービス
```

**各固体オブジェクト（ドメイン）は:**
- ✅ 独立している
- ✅ 明確な境界を持つ
- ✅ ビジネス概念に基づいている
- ✅ 触れることができる具体的な概念
- ✅ 独立してテスト・デプロイできる

**ドメイン（固体オブジェクト）の独立性が、システム全体の保守性と拡張性を決定します。**

### 壺のメタファーが示すもの

```
物理的な壺:
- 壺（容器）に固体を入れる
- 固体は壺の形に影響されるが、その内部構造は独立

Tsubo:
- 壺（マイクロサービス）にドメイン（固体オブジェクト）を入れる
- ドメインは Contract（壺の形）に影響されるが、実装の詳細は独立
- AIがオブジェクトの内部構造を作る
```

---

参考: Domain-Driven Design (DDD), Bounded Context
