# Tsubo フレームワーク設計思想

## 壺（Tsubo）の哲学

### 名前の由来

**Tsubo（壺）** は、日本の伝統的な面積単位であり、小さく区切られた空間を表します。
しかし、Tsubo フレームワークにおける「壺」は、より深い意味を持ちます。

```
      ┌─────────────────────────────────────────┐
      │   壺（Tsubo）= アプリケーション全体       │  ← 人間が形を決める
      │                                         │
      │  ┌──────────┐  ┌──────────┐            │
      │  │  TODO    │  │   User   │   ...      │  ← 固体オブジェクト
      │  │  ドメイン │  │  ドメイン │            │     (各マイクロサービス)
      │  │┌────────┐│  │┌────────┐│            │
      │  ││Contract││  ││Contract││            │  ← Contract（形状）
      │  │└────────┘│  │└────────┘│            │
      │  │  ┌────┐ │  │  ┌────┐ │            │
      │  │  │実装│ │  │  │実装│ │            │  ← AIが決める
      │  │  └────┘ │  │  └────┘ │            │
      │  └──────────┘  └──────────┘            │
      │                                         │
      └─────────────────────────────────────────┘

      1つの壺（アプリケーション）= 複数の固体オブジェクト（ドメイン/マイクロサービス）
```

### カプセル化の新しい意味

**伝統的なカプセル化（OOP）:**
- 内部実装を外部から隠蔽する
- 情報隠蔽によるモジュール性の向上

**Tsubo のカプセル化:**
- **人間から実装の詳細を隠蔽する**
- **AIに任せる領域と人間が決める領域を明確に分離する**
- 壺の中身がどう作用し合うかは、人間が知る必要がない

### AI First の原則

**人間の役割:**
- ✅ **壺の形を決める**（インターフェース、境界）
- ✅ **壺に何を入れるかを決める**（責務、コンテキスト）
- ✅ **壺を覗いた時に何が見えるかを定義する**（期待される振る舞い、I/O）
- ❌ 壺の中身がどう作用し合うかは**知る必要がない**

**AIの役割:**
- ✅ **壺の中身がどう作用し合うかを決める**（実装の詳細）
- ✅ エッジケースの処理
- ✅ エラーハンドリング
- ✅ パフォーマンス最適化
- ❌ インターフェースや責務の決定は**人間に任せる**

### Tsubo の本質

> **壺は、アプリケーション全体を表す容器である。**
>
> **ドメインは、壺の中に入れる固体オブジェクトである。**
> **各固体オブジェクトは、1つのマイクロサービスとなる。**
>
> 1つの壺には、複数の固体オブジェクト（ドメイン）が入る。
> この壺の形（アプリケーションの全体像）は**人が決め**、
> どのオブジェクト（ドメイン）を入れるかも**人が決める**。
>
> 各固体オブジェクト（ドメイン）は**触れるもの**であり、その概念は**人が作る**。
> ただし、各オブジェクトの内部構造がどのように作用するかについては**知る必要がない**。
>
> 故に、それらの内部構造がどのように作用するかは**AIによって定められる**。
>
> 人は壺に対して**どのオブジェクト（ドメイン）を入れるのか**、
> そして各オブジェクトを覗き込んだときに**何が見えるのか**という
> **インターフェース（Contract）のみを気にすべき**である。
>
> **1つの壺（アプリケーション）= 複数の固体オブジェクト（ドメイン/マイクロサービス）**
>
> これにより、各ドメインの独立性が担保され、疎結合なシステムが実現される。

### 物理的なイメージ

```
壺（アプリケーション全体）
  ├─ 固体オブジェクト1 = TODO ドメイン → todo-service
  ├─ 固体オブジェクト2 = User ドメイン → user-service
  └─ 固体オブジェクト3 = Auth ドメイン → auth-service

各固体オブジェクトは:
- 独立している（他と混ざらない）
- 触れることができる（具体的）
- Contract で形状が定義される
- 内部構造は AI が作る

例: TODO アプリケーション
┌─────────────────────────────┐
│    壺（TODO アプリ）         │
│                             │
│  [TODO]  [User]  [Auth]     │ ← 固体オブジェクト
│    ↓       ↓       ↓        │
│  todo-  user-  auth-        │
│  service service service    │
└─────────────────────────────┘
```

---

## 核心思想

### なぜ Tsubo を作るのか

**現代のソフトウェア開発における課題:**
- AI（LLM）は強力だが、大規模なコードベースではハルシネーション（幻覚）が発生しやすい
- モノリシックな実装では、AIが全体像を把握しきれず、コンテキストが散逸する
- 複数の機能を並列に開発したいが、既存のアーキテクチャでは困難
- AIによる開発では、明確な境界と契約がないと、整合性が取れないコードが生成される

**Tsubo のアプローチ:**
マイクロサービスの境界を、AI駆動開発のための「コンテキスト境界」として活用する。
各サービスを小さく、明確で、独立した「壺（Tsubo）」として扱うことで：
- AI が理解・実装しやすいスコープに分割
- 並列実装による開発速度の劇的な向上
- **Contract-driven Testing（CDT）によるハルシネーションの削減**
- 自動検証による品質保証

**重要な考え方:**
仮にマイクロサービス化がベストなアーキテクチャでないとしても、**Contract定義の仕組みから始める**。
なぜなら、境界の定義は常に役立つからである。

Tsubo の Contract は、**3つの役割を持つ Single Source of Truth**：
1. **人間向け**: サービス間の合意仕様書
2. **AI向け**: 「何をすべきか」の明確な指示書（プロンプトコンテキスト）
3. **テスト向け**: バリデーションの基準

## 設計原則

### 0. AI First: 人間はコンセプト、AIは実装

**Tsubo の最も根本的な原則**: 人間とAIの責務を明確に分離する。

**人間が決めること（触れるもの）:**
- 壺の形（インターフェース、境界）
- 壺に何を入れるか（責務、ドメインロジック）
- 壺を覗いた時に何が見えるか（期待される振る舞い、I/O）

**AIが決めること（触れないもの）:**
- 壺の中身がどう作用し合うか（実装の詳細）
- エラーハンドリングの具体的な方法
- パフォーマンス最適化
- エッジケースの処理

**従来の開発との違い:**

| アプローチ | 人間の役割 | AIの役割 |
|----------|-----------|---------|
| 従来 | 設計 + 実装 | コード補完、レビュー |
| **Tsubo** | **Contract定義のみ** | **実装すべて** |

**理由:**
- 人間は「何をすべきか」を考えることに集中できる
- AIは「どう実装するか」を考えることに集中できる
- 役割分担により、ハルシネーションが減る（AIは明確な指示に従うだけ）
- 開発速度が劇的に向上する

### 1. Contract is Everything（契約がすべて）

**実装よりも先に、Contract を定義する。Contract は「壺の設計図」である。**

Contract は単なるAPI定義ではなく、**壺の形と中身を定義するもの**：
- **壺の形**: インターフェース（何を入れるか、何が見えるか）
- **壺の中身**: コンテキスト（責務、制約、期待される振る舞い）
- **壺の使い方**: 依存関係、パフォーマンス要件

Contract の3つの役割：
- **人間向け**: 壺の設計図、サービス間の合意仕様書
- **AI向け**: 「この壺の中身をどう作るか」の明確な指示書（プロンプトコンテキスト）
- **テスト向け**: 壺が正しく機能しているかのバリデーション基準

含まれるべき情報：
- ✅ API スキーマ（型、エンドポイント）
- ✅ **ビジネスコンテキスト**（目的、責務、ドメイン）
- ✅ **セマンティック情報**（意図、振る舞い、エッジケース）
- ✅ 依存関係（なぜ依存するか）
- ✅ パフォーマンス要件
- ✅ 制約と不変条件

**理由:**
- 明確な契約があれば、複数のAIエージェントが並列に実装しても整合性が保たれる
- セマンティック情報（「なぜそうすべきか」）がないと、AIはハルシネーションを起こす
- 1つの定義が3つの目的を果たす（DRY原則）

**重要:** OpenAPI や Protobuf だけでは不十分。型定義だけでなく、**ビジネス上の目的、振る舞いの意図、エッジケースでの期待動作**を含める必要がある。

### 1. Boundary is Domain（境界がドメイン）

**壺は、アプリケーション全体の境界である。**
**固体オブジェクト（ドメイン）は、その中で独立したマイクロサービスとなる。**

**1つの壺（アプリケーション）= 複数の固体オブジェクト（ドメイン/マイクロサービス）**

各固体オブジェクト（ドメイン）には：
- **ドメイン境界**: ビジネス上の概念の境界
- **サービス境界**: 実装上の境界（マイクロサービス）
- **コンテキスト境界**: AIが理解すべきスコープ

これらが一致することで：
- ✅ 各ドメインの独立性が担保される
- ✅ マイクロサービスが疎結合になる
- ✅ AIが一度に理解できるスコープに収まる
- ✅ 各ドメインは独立してテスト・デプロイ可能

**固体オブジェクト（ドメイン）のサイズ感:**
```
小さすぎる固体（過度な分割）:
  ❌ ドメインが細分化されすぎて、全体が複雑に
  ❌ ネットワークオーバーヘッドが増える
  ❌ ドメインロジックが分散してしまう

適切なサイズの固体（1ドメイン = 1サービス）:
  ✅ 明確なビジネス概念の境界
  ✅ ドメインの独立性が担保される
  ✅ AIが一度に理解できる
  ✅ 独立してテスト・デプロイ可能

大きすぎる固体（複数ドメイン混在）:
  ❌ ドメインの境界が曖昧
  ❌ AIがコンテキストを失う
  ❌ ハルシネーションが増える
```

**ドメインの見極め方:**
- **ユビキタス言語**: そのドメイン固有の用語があるか
- **独立性**: 他のドメインに依存せず変更できるか
- **凝集性**: 関連する概念が1つにまとまっているか
- **境界**: 明確な責務の境界があるか

**例:**
```
❌ 悪い例: user-service に todo 管理機能も含める
   → 1つの固体オブジェクトに複数のドメインが混在

✅ 良い例（壺の中に複数の固体オブジェクト）:
   壺（TODO アプリケーション）
   ├─ User 固体（user-service）
   ├─ TODO 固体（todo-service）
   └─ Auth 固体（auth-service）
   → それぞれ独立したドメイン/マイクロサービス
```

**重要:** 各固体オブジェクト（ドメイン）の境界を正しく定義すれば、アプリケーション全体の独立性と保守性が向上する。

### 2. Parallel by Default（デフォルトで並列）

サービス間の依存関係を明示的に管理し、可能な限り並列実装を行う。
- 依存関係グラフの自動解析
- 独立したサービスは同時に複数のAIエージェントで実装
- オーケストレーターによる進捗管理
- 実装中のサービスが互いに干渉しない

**理由:**
- 開発速度の劇的な向上（従来の3-5倍）
- 開発者の待ち時間の最小化
- AIエージェントの効率的な活用

### 3. Verify Continuously（継続的な検証）

実装と同時に、自動的に検証を行う。特に **Contract-driven Testing（CDT）** を核心とする。
- **契約テスト（Contract Testing）**: Contractで定義された仕様への適合性をチェック
- 型安全性チェック: Go/Rustの型システムを活用
- 統合テスト: サービス間の相互作用を検証
- パフォーマンステスト: 契約で定義されたSLAを満たすか確認
- セキュリティスキャン: 脆弱性の早期発見

**理由:**
- AIが生成したコードの品質を保証
- ハルシネーションによるバグを早期に検出
- リグレッションの防止
- 人間のレビュー負荷を軽減

### 4. Go-First, Language-Agnostic Interface（Go優先、言語非依存のインターフェース）

**Contract定義は言語非依存、実装はGo言語を推奨。**

- Contract定義: 言語非依存（YAML）
- OpenAPI/Protobuf との互換性
- **推奨実装言語: Go**
- 将来的に TypeScript, Python もサポート

**なぜ Go言語なのか:**
- ✅ **誰が書いても同じコードになる** → AIのハルシネーション最小化
- ✅ シンプルな言語仕様 → AIが理解しやすい
- ✅ 明示的なエラーハンドリング → 見落とし防止
- ✅ 標準フォーマット（gofmt） → コードスタイル統一
- ✅ マイクロサービスのエコシステム

**詳細は [WHY_GO.md](./docs/WHY_GO.md) を参照。**

**アーキテクチャの統一:**
- Orchestrator: Go
- Validator: Go（当初はRustを検討したが、統一のためGoに）
- 生成サービス: Go（推奨）
- CLI: Go

## 何を作るのか

### コア コンポーネント

#### 1. Tsubo Contract Format
マイクロサービスを定義するための、セマンティック情報を含んだContract定義フォーマット。

**詳細は [CONTRACT_DESIGN.md](./docs/CONTRACT_DESIGN.md) を参照。**

Contract は単なるAPI定義ではなく：
- OpenAPI/Protobuf の良い部分を継承
- ビジネスコンテキスト、意図、振る舞いを記述
- AIが理解しやすい構造化された形式
- 人間が読んで理解しやすい

```yaml
# 例: user-service.tsubo.yaml
service:
  name: user-service
  description: ユーザー管理サービス

interface:
  api:
    - method: GET
      path: /users/{id}
      response: User
    - method: POST
      path: /users
      request: CreateUserRequest
      response: User

dependencies:
  - auth-service
  - database

types:
  User:
    id: string
    name: string
    email: string

tests:
  - name: ユーザー作成テスト
    given: 有効なユーザーデータ
    when: POST /users
    then: 201 Created
```

#### 2. Orchestrator（オーケストレーター）
複数のAIエージェントを管理し、並列実装を調整する。

**機能:**
- サービス定義の解析
- 依存関係グラフの構築
- AIエージェントへのタスク配分
- 実装進捗の監視
- 統合・デプロイの自動化

#### 3. Validator（検証エンジン）
生成されたコードを自動的に検証する。

**機能:**
- 契約適合性のチェック
- 型安全性の検証
- テストの自動実行
- パフォーマンス測定
- セキュリティスキャン

#### 4. Template System（テンプレートシステム）
各言語・フレームワーク向けのベストプラクティステンプレート。

**機能:**
- サービスの初期構造生成
- ボイラープレートコードの自動生成
- ベストプラクティスの組み込み
- カスタムテンプレートのサポート

#### 5. CLI Tool
開発者が Tsubo を操作するためのコマンドラインツール。

```bash
# 新しいサービスを定義
potter new user-service

# サービス定義から実装を生成（AI駆動）
potter build user-service

# 全サービスを並列ビルド
potter build --all --parallel

# 検証の実行
potter verify

# サービスの起動
potter run
```

## 目指すもの

### 短期目標（MVP）
- [ ] Tsubo Contract Format の仕様策定
- [ ] Contract バリデーター（Go実装）
- [ ] 基本的なオーケストレーター（Go実装）
- [ ] AI プロンプト生成エンジン
- [ ] Go サービステンプレート
- [ ] CLI ツール（`potter new`, `potter build`, `potter verify`）
- [ ] デモアプリケーション（3-5のマイクロサービス）

### 中期目標
- [ ] 複数AIプロバイダーのサポート（Claude, GPT-4, etc.）
- [ ] より多くの言語テンプレート（TypeScript, Python, etc.）
- [ ] Web UI for orchestration
- [ ] リアルタイム監視ダッシュボード
- [ ] プラグインシステム

### 長期目標
- [ ] AI駆動開発のデファクトスタンダード
- [ ] エンタープライズ対応（認証、監査、等）
- [ ] クラウドネイティブ統合（K8s, Service Mesh, etc.）
- [ ] エコシステムの形成（コミュニティテンプレート、etc.）

## 成功の指標

1. **開発速度:** 従来の3-5倍の速度でマイクロサービスを実装できる
2. **品質:** AIが生成したコードのバグ率を50%以上削減
3. **並列度:** 平均して5-10のサービスを同時に実装できる
4. **学習曲線:** 新しい開発者が1日以内に productive になれる

## 非目標（やらないこと）

Tsubo は以下を目指さない：

- ❌ **ランタイムオーケストレーション**: Kubernetes、Service Mesh、API Gatewayの代替ではない
  - Tsubo は**開発時のツール**であり、実行時のインフラではない
  - 生成されたサービスは、任意のランタイム環境で動作する

- ❌ **完全な自動化**: 人間のレビューを排除しない
  - AIが生成したコードは、必ず人間がレビューする
  - Contract定義も人間が作成・レビューする
  - Tsubo は開発を加速するが、開発者を置き換えるものではない

- ❌ **モノリシックアプリケーションのサポート**: 境界のないコードベースには適用しない
  - ただし、モノリスを段階的にサービスに分割することは支援する

- ❌ **全ての言語・フレームワークのサポート**: 初期は Go に集中
  - 将来的には TypeScript、Python などに拡張
  - ただし、Contract定義は言語非依存
  - Go は推奨言語として位置づけ

- ❌ **既存のContract定義フォーマットの完全な置き換え**: OpenAPI/Protobuf を拡張する
  - 既存ツールとの互換性を維持
  - 段階的な採用を可能にする

---

> "壺（Tsubo）は小さな空間だが、その集合が美しい庭園を作る。
> 同様に、小さなマイクロサービスの集合が、堅牢なシステムを作る。"
